import SwiftUI
import ZIPFoundation // 引入我们之前添加的库

// MARK: - 1. 数据模型 (无变动)

enum ColorTag: String, Codable, CaseIterable, Identifiable {
    case gray, red, blue, green, yellow, purple
    var id: String { self.rawValue }
    var color: Color {
        switch self {
        case .gray: return .gray
        case .red: return .red
        case .blue: return .blue
        case .green: return .green
        case .yellow: return .yellow
        case .purple: return .purple
        }
    }
    var localizedName: String {
        switch self {
        case .gray: return "灰色"
        case .red: return "红色"
        case .blue: return "蓝色"
        case .green: return "绿色"
        case .yellow: return "黄色"
        case .purple: return "紫色"
        }
    }
}

struct Item: Identifiable, Codable, Equatable {
    var id = UUID()
    var name: String
    var imageFileName: String
    var cabinetNumber: String
    var colorTag: ColorTag = .gray
}

struct Cabinet: Identifiable, Codable, Equatable, Hashable {
    var id = UUID()
    var number: String
    var label: String = "标签"
}

struct Room: Identifiable, Codable, Equatable {
    var id = UUID()
    var name: String
    var cabinets: [Cabinet]
    var layoutPathsCGPoints: [[CGPoint]]?
    var cabinetPositions: [String: CGPoint]?
}

struct OldRoom: Codable {
    var id: UUID
    var name: String
    var cabinetNumbers: [String]
    var layoutPathsCGPoints: [[CGPoint]]?
    var cabinetPositions: [String: CGPoint]?
}

struct BackupData: Codable {
    let rooms: [Room]
    let itemsByCabinet: [String: [Item]]
}

// MARK: - 2. 数据管理器 (无变动)
class StorageManager: ObservableObject {
    @Published var rooms: [Room] = []
    @Published var itemsByCabinet: [String: [Item]] = [:]
    
    private let roomsKey = "HomeStorageAppRooms"
    private let itemsKey = "HomeStorageAppItems"

    init() {
        loadData()
    }
    
    var sortedRooms: [Room] {
        rooms.sorted { $0.name < $1.name }
    }
    
    func moveItem(item: Item, toNewCabinetNumber newNumber: String) -> Bool {
        guard cabinetExists(newNumber), item.cabinetNumber != newNumber else {
            return false
        }

        guard var sourceCabinetItems = itemsByCabinet[item.cabinetNumber] else {
            return false
        }
        sourceCabinetItems.removeAll { $0.id == item.id }

        if sourceCabinetItems.isEmpty {
            itemsByCabinet.removeValue(forKey: item.cabinetNumber)
        } else {
            itemsByCabinet[item.cabinetNumber] = sourceCabinetItems
        }

        var movedItem = item
        movedItem.cabinetNumber = newNumber

        if itemsByCabinet[newNumber] != nil {
            itemsByCabinet[newNumber]?.append(movedItem)
        } else {
            itemsByCabinet[newNumber] = [movedItem]
        }

        saveData()
        return true
    }
    
    func searchItems(query: String) -> [Item] {
        guard !query.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return []
        }
        let allItems = itemsByCabinet.values.flatMap { $0 }
        return allItems.filter { $0.name.localizedCaseInsensitiveContains(query) }
    }
    
    func findLocation(for item: Item) -> (roomName: String, cabinet: Cabinet)? {
        for room in rooms {
            if let cabinet = room.cabinets.first(where: { $0.number == item.cabinetNumber }) {
                return (room.name, cabinet)
            }
        }
        return nil
    }
    
    func findRoom(forCabinetNumber number: String) -> Room? {
        for room in rooms {
            if room.cabinets.contains(where: { $0.number == number }) {
                return room
            }
        }
        return nil
    }
    
    func addRoom(name: String) {
        guard !name.trimmingCharacters(in: .whitespaces).isEmpty,
              !rooms.contains(where: { $0.name == name }) else { return }
        let newRoom = Room(name: name, cabinets: [])
        rooms.append(newRoom)
        saveData()
    }
    
    func deleteRoom(room: Room) {
        for cabinet in room.cabinets {
            if let itemsInCabinet = itemsByCabinet[cabinet.number] {
                for item in itemsInCabinet {
                    deleteImage(fileName: item.imageFileName)
                }
            }
            itemsByCabinet.removeValue(forKey: cabinet.number)
        }
        rooms.removeAll { $0.id == room.id }
        saveData()
    }
    
    func addCabinet(number: String, to roomID: UUID) -> Bool {
        guard !number.trimmingCharacters(in: .whitespaces).isEmpty,
              !cabinetExists(number),
              let roomIndex = rooms.firstIndex(where: { $0.id == roomID }) else {
            return false
        }
        let newCabinet = Cabinet(number: number)
        rooms[roomIndex].cabinets.append(newCabinet)
        rooms[roomIndex].cabinets.sort { $0.number < $1.number }
        saveData()
        return true
    }
    
    func updateCabinetLabel(cabinetID: UUID, newLabel: String, in roomID: UUID) {
        guard let roomIndex = rooms.firstIndex(where: { $0.id == roomID }),
              let cabinetIndex = rooms[roomIndex].cabinets.firstIndex(where: { $0.id == cabinetID }) else {
            return
        }
        rooms[roomIndex].cabinets[cabinetIndex].label = newLabel.isEmpty ? "标签" : newLabel
        saveData()
    }

    func deleteCabinet(cabinetID: UUID, from roomID: UUID) {
        guard let roomIndex = rooms.firstIndex(where: { $0.id == roomID }),
              let cabinetToDelete = rooms[roomIndex].cabinets.first(where: { $0.id == cabinetID }) else {
            return
        }
        
        let cabinetNumber = cabinetToDelete.number
        if let itemsInCabinet = itemsByCabinet[cabinetNumber] {
            for item in itemsInCabinet {
                deleteImage(fileName: item.imageFileName)
            }
            itemsByCabinet.removeValue(forKey: cabinetNumber)
        }
        
        rooms[roomIndex].cabinets.removeAll { $0.id == cabinetID }
        saveData()
    }
    
    func updateItemColor(itemID: UUID, inCabinet cabinetNumber: String, to newColor: ColorTag) {
        guard let cabinetIndex = itemsByCabinet[cabinetNumber]?.firstIndex(where: { $0.id == itemID }) else { return }
        itemsByCabinet[cabinetNumber]?[cabinetIndex].colorTag = newColor
        saveData()
    }
    
    func items(for colorTag: ColorTag) -> [Item] {
        itemsByCabinet.values.flatMap { $0 }.filter { $0.colorTag == colorTag }.sorted { $0.name < $1.name }
    }
    
    func deleteItem(item: Item) {
        deleteImage(fileName: item.imageFileName)
        guard var itemsInCabinet = itemsByCabinet[item.cabinetNumber] else { return }
        itemsInCabinet.removeAll { $0.id == item.id }
        
        if itemsInCabinet.isEmpty {
            itemsByCabinet.removeValue(forKey: item.cabinetNumber)
        } else {
            itemsByCabinet[item.cabinetNumber] = itemsInCabinet
        }
        saveData()
    }
    
    func cabinetExists(_ number: String) -> Bool {
        return rooms.flatMap { $0.cabinets }.map { $0.number }.contains(number)
    }
    
    func addItem(_ item: Item) {
        if itemsByCabinet[item.cabinetNumber] != nil {
            itemsByCabinet[item.cabinetNumber]?.append(item)
        } else {
            itemsByCabinet[item.cabinetNumber] = [item]
        }
        saveData()
    }
    
    func createRoom(name: String, forCabinet cabinetNumber: String, withItem item: Item) {
        let newCabinet = Cabinet(number: cabinetNumber)
        let newRoom = Room(name: name, cabinets: [newCabinet])
        rooms.append(newRoom)
        addItem(item)
    }
    
    func assignCabinetToRoom(cabinetNumber: String, toRoomID: UUID, withItem item: Item) {
        if let index = rooms.firstIndex(where: { $0.id == toRoomID }) {
            if !rooms[index].cabinets.contains(where: { $0.number == cabinetNumber }) {
                let newCabinet = Cabinet(number: cabinetNumber)
                rooms[index].cabinets.append(newCabinet)
                rooms[index].cabinets.sort { $0.number < $1.number }
            }
        }
        addItem(item)
    }
    
    func updateRoomLayout(for roomID: UUID, layout: [[CGPoint]], positions: [String: CGPoint]) {
        if let index = rooms.firstIndex(where: { $0.id == roomID }) {
            rooms[index].layoutPathsCGPoints = layout
            rooms[index].cabinetPositions = positions
            saveData()
        }
    }
    
    func saveData() {
        let encoder = JSONEncoder()
        if let encodedRooms = try? encoder.encode(rooms) {
            UserDefaults.standard.set(encodedRooms, forKey: roomsKey)
        }
        if let encodedItems = try? encoder.encode(itemsByCabinet) {
            UserDefaults.standard.set(encodedItems, forKey: itemsKey)
        }
    }
    
    private func loadData() {
        let decoder = JSONDecoder()
        
        if let roomsData = UserDefaults.standard.data(forKey: roomsKey) {
            if let decodedRooms = try? decoder.decode([Room].self, from: roomsData) {
                self.rooms = decodedRooms
            } else if let decodedOldRooms = try? decoder.decode([OldRoom].self, from: roomsData) {
                self.rooms = decodedOldRooms.map { oldRoom in
                    let newCabinets = oldRoom.cabinetNumbers.map { Cabinet(number: $0) }
                    return Room(id: oldRoom.id, name: oldRoom.name, cabinets: newCabinets, layoutPathsCGPoints: oldRoom.layoutPathsCGPoints, cabinetPositions: oldRoom.cabinetPositions)
                }
                saveData()
            }
        }
        
        if let itemsData = UserDefaults.standard.data(forKey: itemsKey), let decodedItems = try? decoder.decode([String: [Item]].self, from: itemsData) {
            self.itemsByCabinet = decodedItems
        }
    }
    
    private func getDocumentsDirectory() -> URL {
        return FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }
    
    func saveImage(image: UIImage) -> String? {
        guard let data = image.jpegData(compressionQuality: 0.8) else { return nil }
        let fileName = UUID().uuidString + ".jpg"
        let fileURL = getDocumentsDirectory().appendingPathComponent(fileName)
        do {
            try data.write(to: fileURL, options: [.atomicWrite, .completeFileProtection])
            return fileName
        } catch {
            print("Error saving image: \(error)")
            return nil
        }
    }
    
    func loadImage(fileName: String) -> UIImage? {
        let fileURL = getDocumentsDirectory().appendingPathComponent(fileName)
        return UIImage(contentsOfFile: fileURL.path)
    }
    
    private func deleteImage(fileName: String) {
        let fileURL = getDocumentsDirectory().appendingPathComponent(fileName)
        if FileManager.default.fileExists(atPath: fileURL.path) {
            do {
                try FileManager.default.removeItem(at: fileURL)
            } catch {
                print("Error deleting image: \(error)")
            }
        }
    }
    
    func prepareBackupData() -> BackupData {
        return BackupData(rooms: self.rooms, itemsByCabinet: self.itemsByCabinet)
    }

    func restoreFromBackup(data: BackupData, imageFiles: [URL]) {
        self.rooms = []
        self.itemsByCabinet = [:]
        clearAllImages()

        for imageURL in imageFiles {
            do {
                let destURL = getDocumentsDirectory().appendingPathComponent(imageURL.lastPathComponent)
                try FileManager.default.copyItem(at: imageURL, to: destURL)
            } catch {
                print("Error copying restored image: \(error)")
            }
        }
        
        self.rooms = data.rooms
        self.itemsByCabinet = data.itemsByCabinet
        saveData()
    }
    
    func getAllImageFileNames() -> Set<String> {
        return Set(itemsByCabinet.values.flatMap { $0 }.map { $0.imageFileName })
    }
    
    private func clearAllImages() {
        let fileManager = FileManager.default
        let documentsURL = getDocumentsDirectory()
        do {
            let fileURLs = try fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: nil)
            for fileURL in fileURLs where fileURL.pathExtension.lowercased() == "jpg" {
                try fileManager.removeItem(at: fileURL)
            }
        } catch {
            print("Error clearing images: \(error)")
        }
    }
}


// MARK: - 3. 主视图 (无变动)
enum ActiveSheet: Identifiable {
    case addItem
    case assignRoom(item: Item)
    var id: String {
        switch self {
        case .addItem: return "addItem"
        case .assignRoom(let item): return "assignRoom-\(item.id)"
        }
    }
}

struct ContentView: View {
    @StateObject private var storageManager = StorageManager()
    @State private var activeSheet: ActiveSheet?
    @Environment(\.scenePhase) private var scenePhase
    
    @State private var isShowingAddRoomAlert = false
    @State private var newRoomName = ""
    @State private var roomToConfirmDelete: Room?
    
    @State private var searchText = ""
    
    private var searchResults: [Item] {
        storageManager.searchItems(query: searchText)
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                if searchText.isEmpty {
                    ColorFilterView(storageManager: storageManager)
                }
                
                ZStack(alignment: .bottomTrailing) {
                    if !searchText.isEmpty {
                        List(searchResults) { item in
                            NavigationLink(destination: CabinetDetailView(storageManager: storageManager, cabinetNumber: item.cabinetNumber)) {
                                SearchResultRow(storageManager: storageManager, item: item)
                            }
                        }
                    } else if storageManager.sortedRooms.isEmpty && storageManager.itemsByCabinet.isEmpty {
                        Text("还没有房间和物品\n点击左上角“+”添加房间\n或点击右下角按钮添加物品").font(.title2).foregroundColor(.gray).multilineTextAlignment(.center).padding()
                    } else {
                        List {
                            Section(header: Text("我的房间").font(.subheadline)) {
                                ForEach(storageManager.sortedRooms) { room in
                                    NavigationLink(destination: RoomDetailView(storageManager: storageManager, roomID: room.id)) {
                                        HStack {
                                            Image(systemName: "house.fill").foregroundColor(.blue)
                                            Text(room.name).font(.headline)
                                            Spacer()
                                            Text("\(room.cabinets.count) 个柜子").foregroundColor(.secondary)
                                        }.padding(.vertical, 8)
                                    }
                                }
                                .onDelete(perform: confirmDelete)
                            }
                        }
                    }
                    
                    Button(action: { activeSheet = .addItem }) {
                        Image(systemName: "plus.circle.fill").resizable().frame(width: 60, height: 60).foregroundColor(.accentColor).shadow(radius: 10).padding()
                    }
                }
            }
            .navigationTitle("我的收纳")
            .searchable(text: $searchText, prompt: "搜索物品名称...")
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        newRoomName = ""
                        isShowingAddRoomAlert = true
                    }) {
                        Image(systemName: "plus")
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    NavigationLink(destination: SettingsView(storageManager: storageManager)) {
                        Image(systemName: "gearshape.fill")
                    }
                }
            }
            .sheet(item: $activeSheet) { sheetType in
                switch sheetType {
                case .addItem:
                    AddItemView(storageManager: storageManager) { item in
                        if let item = item { activeSheet = .assignRoom(item: item) } else { activeSheet = nil }
                    }
                case .assignRoom(let item):
                    RoomAssignmentView(storageManager: storageManager, item: item) { activeSheet = nil }
                }
            }
            .alert("添加新房间", isPresented: $isShowingAddRoomAlert) {
                TextField("输入房间名称", text: $newRoomName)
                Button("添加") {
                    storageManager.addRoom(name: newRoomName)
                }
                Button("取消", role: .cancel) {}
            } message: {
                Text("请输入一个独一无二的房间名称。")
            }
            .alert("确认删除", isPresented: .constant(roomToConfirmDelete != nil), actions: {
                Button("删除", role: .destructive) {
                    if let room = roomToConfirmDelete {
                        storageManager.deleteRoom(room: room)
                    }
                    roomToConfirmDelete = nil
                }
                Button("取消", role: .cancel) {
                    roomToConfirmDelete = nil
                }
            }, message: {
                Text("确定要删除房间 “\(roomToConfirmDelete?.name ?? "")” 吗？\n此操作将同时删除该房间内的所有柜子和物品，且无法撤销。")
            })
        }
        .onChange(of: scenePhase) { _, newPhase in
            if newPhase == .background || newPhase == .inactive {
                storageManager.saveData()
            }
        }
    }
    
    private func confirmDelete(at offsets: IndexSet) {
        self.roomToConfirmDelete = offsets.map { storageManager.sortedRooms[$0] }.first
    }
}

// MARK: - 4. 新增与辅助视图 (无变动)
struct SearchResultRow: View {
    @ObservedObject var storageManager: StorageManager
    let item: Item
    
    var body: some View {
        HStack {
            if let uiImage = storageManager.loadImage(fileName: item.imageFileName) {
                Image(uiImage: uiImage)
                    .resizable()
                    .frame(width: 50, height: 50)
                    .aspectRatio(contentMode: .fill)
                    .clipped()
                    .cornerRadius(4)
            } else {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 50, height: 50)
                    .cornerRadius(4)
                    .overlay(Image(systemName: "photo.fill").foregroundColor(.white))
            }
            
            VStack(alignment: .leading) {
                Text(item.name).font(.headline)
                if let location = storageManager.findLocation(for: item) {
                    Text("\(location.roomName) - \(location.cabinet.label): \(location.cabinet.number)")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            Circle()
                .fill(item.colorTag.color)
                .frame(width: 15, height: 15)
        }
        .padding(.vertical, 4)
    }
}


struct ColorFilterView: View {
    @ObservedObject var storageManager: StorageManager

    var body: some View {
        VStack(alignment: .leading) {
            Text("按颜色查找")
                .font(.headline)
                .padding(.horizontal)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 20) {
                    ForEach(ColorTag.allCases) { tag in
                        NavigationLink(destination: FilteredItemsView(storageManager: storageManager, colorTag: tag)) {
                            VStack {
                                Circle()
                                    .fill(tag.color)
                                    .frame(width: 50, height: 50)
                                    .shadow(color: .black.opacity(0.2), radius: 2, y: 1)
                                Text(tag.localizedName)
                                    .font(.caption)
                                    .foregroundColor(.primary)
                            }
                        }
                    }
                }
                .padding()
            }
        }
        .padding(.top)
        .background(Color(.systemGray6))
    }
}

struct FilteredItemsView: View {
    @ObservedObject var storageManager: StorageManager
    let colorTag: ColorTag

    private var items: [Item] {
        storageManager.items(for: colorTag)
    }

    var body: some View {
        if items.isEmpty {
            Text("没有找到标记为“\(colorTag.localizedName)”的物品")
                .foregroundColor(.gray)
                .navigationTitle("\(colorTag.localizedName) 物品")
        } else {
            List(items) { item in
                NavigationLink(destination: CabinetDetailView(storageManager: storageManager, cabinetNumber: item.cabinetNumber)) {
                    SearchResultRow(storageManager: storageManager, item: item)
                }
            }
            .navigationTitle("\(colorTag.localizedName) 物品 (\(items.count))")
        }
    }
}

// MARK: - 5. 设置页面 (无变动)
struct SettingsView: View {
    @ObservedObject var storageManager: StorageManager
    @State private var isShowingBackupSheet = false
    @State private var isShowingRestorePicker = false
    @State private var backupURL: URL?
    @State private var alertMessage: String?
    @State private var isShowingAlert = false
    
    private var backupDateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd-HHmm"
        return formatter
    }
    
    var body: some View {
        Form {
            Section(header: Text("数据管理")) {
                Button(action: createBackup) {
                    Label("备份数据", systemImage: "arrow.up.doc.fill")
                }
                Button(action: { isShowingRestorePicker = true }) {
                    Label("从备份恢复", systemImage: "arrow.down.doc.fill")
                }
            }
        }
        .navigationTitle("设置")
        .sheet(isPresented: $isShowingBackupSheet) {
            if let url = backupURL {
                ShareSheet(activityItems: [url])
            }
        }
        .fileImporter(isPresented: $isShowingRestorePicker, allowedContentTypes: [.zip]) { result in
            switch result {
            case .success(let url):
                restoreFromBackup(url: url)
            case .failure(let error):
                print("Error picking file: \(error.localizedDescription)")
            }
        }
        .alert("提示", isPresented: $isShowingAlert) {
            Button("好") {}
        } message: {
            Text(alertMessage ?? "")
        }
    }
    
    func createBackup() {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        let imagesDir = tempDir.appendingPathComponent("images")
        do {
            try FileManager.default.createDirectory(at: imagesDir, withIntermediateDirectories: true)
            let backupData = storageManager.prepareBackupData()
            let metadataURL = tempDir.appendingPathComponent("metadata.json")
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            let data = try encoder.encode(backupData)
            try data.write(to: metadataURL)
            let imageFileNames = storageManager.getAllImageFileNames()
            let documentsDir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            for fileName in imageFileNames {
                let sourceURL = documentsDir.appendingPathComponent(fileName)
                let destURL = imagesDir.appendingPathComponent(fileName)
                if FileManager.default.fileExists(atPath: sourceURL.path) {
                    try FileManager.default.copyItem(at: sourceURL, to: destURL)
                }
            }
            let dateString = backupDateFormatter.string(from: Date())
            let zipURL = FileManager.default.temporaryDirectory.appendingPathComponent("我的收纳备份-\(dateString).zip")
            if FileManager.default.fileExists(atPath: zipURL.path) {
                try FileManager.default.removeItem(at: zipURL)
            }
            try FileManager.default.zipItem(at: tempDir, to: zipURL)
            self.backupURL = zipURL
            self.isShowingBackupSheet = true
        } catch {
            alertMessage = "备份失败: \(error.localizedDescription)"
            isShowingAlert = true
        }
    }
    
    func restoreFromBackup(url: URL) {
        let tempUnzipDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        let localZipURL = FileManager.default.temporaryDirectory.appendingPathComponent(url.lastPathComponent)
        do {
            guard url.startAccessingSecurityScopedResource() else {
                throw NSError(domain: "AppError", code: 1, userInfo: [NSLocalizedDescriptionKey: "无法访问文件"])
            }
            if FileManager.default.fileExists(atPath: localZipURL.path) {
                try FileManager.default.removeItem(at: localZipURL)
            }
            try FileManager.default.copyItem(at: url, to: localZipURL)
            url.stopAccessingSecurityScopedResource()
            try FileManager.default.createDirectory(at: tempUnzipDir, withIntermediateDirectories: true)
            try FileManager.default.unzipItem(at: localZipURL, to: tempUnzipDir)
            guard let contentDirURL = try FileManager.default.contentsOfDirectory(at: tempUnzipDir, includingPropertiesForKeys: nil, options: .skipsHiddenFiles).first else {
                throw NSError(domain: "AppError", code: 2, userInfo: [NSLocalizedDescriptionKey: "备份文件格式不正确"])
            }
            let metadataURL = contentDirURL.appendingPathComponent("metadata.json")
            let metadata = try Data(contentsOf: metadataURL)
            let backupData = try JSONDecoder().decode(BackupData.self, from: metadata)
            let imagesDir = contentDirURL.appendingPathComponent("images")
            let imageFiles = try FileManager.default.contentsOfDirectory(at: imagesDir, includingPropertiesForKeys: nil)
            storageManager.restoreFromBackup(data: backupData, imageFiles: imageFiles)
            alertMessage = "数据已成功恢复！"
            isShowingAlert = true
        } catch {
            alertMessage = "恢复失败: \(error.localizedDescription)"
            isShowingAlert = true
        }
        try? FileManager.default.removeItem(at: tempUnzipDir)
        try? FileManager.default.removeItem(at: localZipURL)
    }
}

// MARK: - 6. 其他视图 (已更新)
struct RoomDetailView: View {
    @ObservedObject var storageManager: StorageManager
    let roomID: UUID
    
    @State private var isShowingAddCabinetAlert = false
    @State private var newCabinetNumber = ""
    @State private var cabinetToConfirmDelete: Cabinet?
    @State private var errorMessage: String?
    
    @State private var cabinetToEdit: Cabinet?
    @State private var editingLabelText: String = ""

    private var room: Room {
        storageManager.rooms.first { $0.id == roomID } ?? Room(name: "已删除", cabinets: [])
    }
    
    private var sortedCabinets: [Cabinet] {
        room.cabinets.sorted { $0.number.localizedStandardCompare($1.number) == .orderedAscending }
    }

    var body: some View {
        if room.name == "已删除" {
            Text("该房间已被删除。").foregroundColor(.gray)
                .navigationTitle("")
        } else {
            List {
                ForEach(sortedCabinets) { cabinet in
                    NavigationLink(destination: CabinetDetailView(storageManager: storageManager, cabinetNumber: cabinet.number)) {
                        HStack {
                            Image(systemName: "archivebox.fill").foregroundColor(.brown)
                            Text("\(cabinet.label):")
                                .fontWeight(.bold)
                            Text(cabinet.number)
                            Spacer()
                            Text("\(storageManager.itemsByCabinet[cabinet.number]?.count ?? 0) 件").foregroundColor(.secondary)
                        }
                        .padding(.vertical, 4)
                    }
                    .contentShape(Rectangle()) // 确保整行都可触发手势
                    .onLongPressGesture {
                        self.cabinetToEdit = cabinet
                        self.editingLabelText = cabinet.label
                    }
                }
                .onDelete(perform: confirmDelete)
            }
            .listStyle(InsetGroupedListStyle())
            .navigationTitle(room.name)
            .toolbar {
                ToolbarItemGroup(placement: .navigationBarTrailing) {
                    Button("添加柜子") {
                        newCabinetNumber = ""
                        isShowingAddCabinetAlert = true
                    }
                    
                    if room.cabinets.count >= 2 {
                        let roomBinding = Binding<Room>(
                            get: { self.room },
                            set: { updatedRoom in
                                if let index = storageManager.rooms.firstIndex(where: { $0.id == roomID }) {
                                    storageManager.rooms[index] = updatedRoom
                                }
                            }
                        )
                        NavigationLink(destination: RoomLayoutView(storageManager: storageManager, room: roomBinding)) {
                            Image(systemName: "map.fill")
                        }
                    }
                }
            }
            .alert("添加新柜子", isPresented: $isShowingAddCabinetAlert) {
                TextField("输入柜子编号", text: $newCabinetNumber)
                    .keyboardType(.numberPad)
                Button("添加", action: addCabinet)
                Button("取消", role: .cancel) {}
            } message: {
                Text("请输入一个在所有房间中都唯一的柜子编号。")
            }
            .alert("确认删除", isPresented: .constant(cabinetToConfirmDelete != nil), actions: {
                Button("删除", role: .destructive) {
                    if let cabinet = cabinetToConfirmDelete {
                        storageManager.deleteCabinet(cabinetID: cabinet.id, from: roomID)
                    }
                    cabinetToConfirmDelete = nil
                }
                Button("取消", role: .cancel) { cabinetToConfirmDelete = nil }
            }, message: {
                Text("确定要删除柜子 “\(cabinetToConfirmDelete?.label ?? ""): \(cabinetToConfirmDelete?.number ?? "")” 吗？\n此操作将同时删除柜内所有物品且无法撤销。")
            })
            .alert("编辑标签", isPresented: .constant(cabinetToEdit != nil)) {
                TextField("输入新标签", text: $editingLabelText)
                Button("保存") {
                    if let cabinet = cabinetToEdit {
                        storageManager.updateCabinetLabel(cabinetID: cabinet.id, newLabel: editingLabelText, in: roomID)
                    }
                    cabinetToEdit = nil
                }
                Button("取消", role: .cancel) {
                    cabinetToEdit = nil
                }
            }
            .alert("错误", isPresented: .constant(errorMessage != nil), actions: {
                Button("好") { errorMessage = nil }
            }, message: {
                Text(errorMessage ?? "发生未知错误")
            })
        }
    }
    
    private func confirmDelete(at offsets: IndexSet) {
        self.cabinetToConfirmDelete = offsets.map { sortedCabinets[$0] }.first
    }
    
    private func addCabinet() {
        let success = storageManager.addCabinet(number: newCabinetNumber, to: roomID)
        if !success {
            self.errorMessage = "无法添加柜子。请确保编号不为空且未被使用。"
        }
    }
}

struct CabinetItemView: View {
    @ObservedObject var storageManager: StorageManager
    let item: Item
    
    var body: some View {
        ZStack(alignment: .bottom) {
            if let uiImage = storageManager.loadImage(fileName: item.imageFileName) {
                Image(uiImage: uiImage).resizable().aspectRatio(contentMode: .fill).frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity).aspectRatio(1, contentMode: .fit).clipped().cornerRadius(8)
            } else {
                let greyRectangle = Rectangle().fill(Color.gray.opacity(0.3)).aspectRatio(1, contentMode: .fit).cornerRadius(8)
                let photoIcon = Image(systemName: "photo.fill").foregroundColor(.white).font(.largeTitle)
                greyRectangle.overlay(photoIcon)
            }
            Text(item.name).font(.caption).bold().foregroundColor(.white).padding(4).frame(maxWidth: .infinity).background(Color.black.opacity(0.5)).cornerRadius(8, c: [.bottomLeft, .bottomRight])
            
            ZStack {
                Circle()
                    .fill(item.colorTag.color)
            }
            .frame(width: 15, height: 15)
            .overlay(Circle().stroke(Color.white, lineWidth: 2))
            .shadow(radius: 2)
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topTrailing)
            .padding(6)
        }
        .shadow(radius: 3)
    }
}

struct CabinetDetailView: View {
    @ObservedObject var storageManager: StorageManager
    let cabinetNumber: String
    @State private var itemToConfirmDelete: Item?
    @State private var isShowingAddItemSheet = false
    
    @State private var itemToMove: Item?
    @State private var destinationCabinetNumber: String = ""
    @State private var moveErrorMessage: String?
    
    private let columns: [GridItem] = Array(repeating: .init(.flexible()), count: 3)
    
    private var parentRoom: Room? {
        storageManager.findRoom(forCabinetNumber: cabinetNumber)
    }
    
    var body: some View {
        ScrollView {
            LazyVGrid(columns: columns, spacing: 15) {
                ForEach(storageManager.itemsByCabinet[cabinetNumber] ?? []) { item in
                    CabinetItemView(storageManager: storageManager, item: item)
                        .contextMenu {
                            Text("修改颜色标签").font(.subheadline)
                            ForEach(ColorTag.allCases) { tag in
                                Button {
                                    storageManager.updateItemColor(itemID: item.id, inCabinet: cabinetNumber, to: tag)
                                } label: {
                                    Label(tag.localizedName, systemImage: item.colorTag == tag ? "checkmark.circle.fill" : "circle.fill")
                                        .tint(tag.color)
                                }
                            }
                            Divider()
                            Button(role: .destructive) {
                                itemToConfirmDelete = item
                            } label: {
                                Label("删除物品", systemImage: "trash")
                            }
                            Button {
                                itemToMove = item
                                destinationCabinetNumber = ""
                            } label: {
                                Label("移动物品...", systemImage: "arrow.right.square")
                            }
                        }
                }
            }.padding()
        }
        .navigationTitle("柜子 \(cabinetNumber)")
        .toolbar {
            ToolbarItemGroup(placement: .navigationBarTrailing) {
                if let room = parentRoom, room.cabinets.count >= 2 {
                    let roomBinding = Binding<Room>(
                        get: { storageManager.rooms.first { $0.id == room.id } ?? room },
                        set: { updatedRoom in
                            if let index = storageManager.rooms.firstIndex(where: { $0.id == room.id }) {
                                storageManager.rooms[index] = updatedRoom
                            }
                        }
                    )
                    NavigationLink(destination: RoomLayoutView(storageManager: storageManager, room: roomBinding)) {
                        Image(systemName: "map.fill")
                    }
                }
                
                Button(action: { isShowingAddItemSheet = true }) {
                    Image(systemName: "plus")
                }
            }
        }
        .sheet(isPresented: $isShowingAddItemSheet) {
            AddItemView(storageManager: storageManager, prefilledCabinetNumber: cabinetNumber) { _ in
                isShowingAddItemSheet = false
            }
        }
        .alert(item: $itemToConfirmDelete) { item in
            Alert(title: Text("确认删除"), message: Text("您确定要删除物品 “\(item.name)” 吗？"), primaryButton: .destructive(Text("删除")) { storageManager.deleteItem(item: item) }, secondaryButton: .cancel(Text("取消")))
        }
        .alert("移动物品", isPresented: .constant(itemToMove != nil)) {
            TextField("输入目标柜子编号", text: $destinationCabinetNumber)
                .keyboardType(.numberPad)
            Button("移动") {
                if let item = itemToMove {
                    let success = storageManager.moveItem(item: item, toNewCabinetNumber: destinationCabinetNumber)
                    if !success {
                        self.moveErrorMessage = "移动失败。请检查柜子编号是否存在且与当前柜子不同。"
                    }
                }
                itemToMove = nil
            }
            Button("取消", role: .cancel) {
                itemToMove = nil
            }
        } message: {
            Text("将 “\(itemToMove?.name ?? "")” 移动到哪个柜子？")
        }
        .alert("错误", isPresented: .constant(moveErrorMessage != nil)) {
            Button("好") { moveErrorMessage = nil }
        } message: {
            Text(moveErrorMessage ?? "")
        }
    }
}

struct AddItemView: View {
    @ObservedObject var storageManager: StorageManager
    let prefilledCabinetNumber: String?
    var onComplete: (Item?) -> Void
    
    init(storageManager: StorageManager, prefilledCabinetNumber: String? = nil, onComplete: @escaping (Item?) -> Void) {
        self.storageManager = storageManager
        self.prefilledCabinetNumber = prefilledCabinetNumber
        self.onComplete = onComplete
        
        if let number = prefilledCabinetNumber {
            _cabinetNumber = State(initialValue: number)
        }
    }
    
    @State private var itemName: String = ""
    @State private var cabinetNumber: String = ""
    @State private var selectedImage: UIImage?
    @State private var isImagePickerShowing = false
    @State private var sourceType: UIImagePickerController.SourceType = .photoLibrary
    @State private var isShowingSourcePicker = false
    @State private var colorTag: ColorTag = .gray
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("物品信息")) {
                    TextField("输入物品名称 (例如: 充电宝)", text: $itemName)
                    TextField("输入柜子编号", text: $cabinetNumber)
                        .keyboardType(.numberPad)
                        .disabled(prefilledCabinetNumber != nil)
                }
                
                Section(header: Text("标签颜色")) {
                    Picker("颜色", selection: $colorTag) {
                        ForEach(ColorTag.allCases) { tag in
                            Text(tag.localizedName).tag(tag)
                        }
                    }
                    .pickerStyle(.segmented)
                }
                
                Section(header: Text("物品照片")) {
                    if let image = selectedImage {
                        Image(uiImage: image).resizable().scaledToFit().cornerRadius(10).padding(.vertical)
                    }
                    Button(action: { self.isShowingSourcePicker = true }) {
                        HStack {
                            Image(systemName: "camera.fill")
                            Text(selectedImage == nil ? "拍照或选择照片" : "重新选择")
                        }
                    }
                }
            }
            .navigationTitle("添加新物品")
            .navigationBarItems(
                leading: Button("取消") { onComplete(nil) },
                trailing: Button("保存", action: saveItem).disabled(selectedImage == nil || cabinetNumber.isEmpty || itemName.isEmpty)
            )
            .sheet(isPresented: $isImagePickerShowing) {
                ImagePicker(selectedImage: $selectedImage, sourceType: self.sourceType)
            }
            .confirmationDialog("选择照片来源", isPresented: $isShowingSourcePicker, titleVisibility: .visible) {
                if UIImagePickerController.isSourceTypeAvailable(.camera) {
                    Button("拍照") {
                        self.sourceType = .camera
                        self.isImagePickerShowing = true
                    }
                }
                Button("从相册选择") {
                    self.sourceType = .photoLibrary
                    self.isImagePickerShowing = true
                }
            }
        }
    }
    
    private func saveItem() {
        guard let image = selectedImage, !cabinetNumber.isEmpty, !itemName.isEmpty else { return }
        guard let fileName = storageManager.saveImage(image: image) else { return }
        let item = Item(name: itemName, imageFileName: fileName, cabinetNumber: cabinetNumber, colorTag: colorTag)
        if storageManager.cabinetExists(cabinetNumber) {
            storageManager.addItem(item)
            onComplete(nil)
        } else {
            onComplete(item)
        }
    }
}

struct RoomAssignmentView: View {
    @ObservedObject var storageManager: StorageManager
    let item: Item
    var onComplete: () -> Void
    
    @State private var isCreatingNewRoom = false
    @State private var newRoomName = ""
    
    var body: some View {
        NavigationView {
            VStack {
                if isCreatingNewRoom {
                    Form {
                        Section(header: Text("为柜子 \(item.cabinetNumber) 创建新房间")) {
                            TextField("输入新房间名称", text: $newRoomName)
                        }
                    }
                    Button("保存房间") {
                        if !newRoomName.isEmpty {
                            storageManager.createRoom(name: newRoomName, forCabinet: item.cabinetNumber, withItem: item)
                            onComplete()
                        }
                    }.padding().disabled(newRoomName.isEmpty)
                } else {
                    List {
                        Section(header: Text("将柜子 \(item.cabinetNumber) 归入哪个房间?")) {
                            Button(action: { isCreatingNewRoom = true }) {
                                HStack {
                                    Image(systemName: "plus.circle.fill")
                                    Text("创建新房间")
                                }
                            }
                            ForEach(storageManager.sortedRooms) { room in
                                Button(room.name) {
                                    storageManager.assignCabinetToRoom(cabinetNumber: item.cabinetNumber, toRoomID: room.id, withItem: item)
                                    onComplete()
                                }
                            }
                        }
                    }
                }
            }.navigationTitle("分配房间").navigationBarItems(leading: Button("取消") { onComplete() })
        }
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Binding var selectedImage: UIImage?
    @Environment(\.presentationMode) var presentationMode
    var sourceType: UIImagePickerController.SourceType
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.selectedImage = uiImage
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

struct RoomLayoutView: View {
    @ObservedObject var storageManager: StorageManager
    @Binding var room: Room
    @Environment(\.presentationMode) var presentationMode
    
    @State private var paths: [[CGPoint]] = []
    @State private var currentDrawingPath: [CGPoint] = []
    @State private var isDrawingMode = true
    @State private var previewingCabinetNumber: String?
    
    var body: some View {
        VStack(spacing: 0) {
            Text(isDrawingMode ? "请用手指绘制房间布局" : "请拖动柜子到指定位置").font(.headline).padding().frame(maxWidth: .infinity).background(Color.blue.opacity(0.1))
            GeometryReader { geometry in
                ZStack {
                    Canvas { context, size in
                        for pathPoints in paths {
                            var path = Path()
                            path.addLines(pathPoints)
                            context.stroke(path, with: .color(.black), lineWidth: 4)
                        }
                        var currentPath = Path()
                        currentPath.addLines(currentDrawingPath)
                        context.stroke(currentPath, with: .color(.red), lineWidth: 4)
                    }.gesture(
                        DragGesture(minimumDistance: 0)
                            .onChanged { value in
                                guard isDrawingMode else { return }
                                currentDrawingPath.append(value.location)
                            }
                            .onEnded { value in
                                guard isDrawingMode else { return }
                                paths.append(currentDrawingPath)
                                currentDrawingPath = []
                            }
                    )
                    
                    ForEach(room.cabinets) { cabinet in
                        CabinetIconView(label: cabinet.label, number: cabinet.number)
                            .position(room.cabinetPositions?[cabinet.number] ?? CGPoint(x: 100, y: 100))
                            .gesture(
                                DragGesture()
                                    .onChanged { value in
                                        guard !isDrawingMode else { return }
                                        var newPositions = room.cabinetPositions ?? [:]
                                        newPositions[cabinet.number] = value.location
                                        room.cabinetPositions = newPositions
                                    }
                            )
                            .onTapGesture(count: 2) {
                                self.previewingCabinetNumber = cabinet.number
                            }
                    }
                }
            }.background(Color.gray.opacity(0.15)).border(Color.gray, width: 1)
        }
        .navigationTitle("房间布局: \(room.name)")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItemGroup(placement: .navigationBarTrailing) {
                Button(action: { isDrawingMode.toggle() }) {
                    Image(systemName: isDrawingMode ? "hand.draw.fill" : "arrow.up.and.down.and.arrow.left.and.right")
                }
                Button(action: {
                    paths.removeAll()
                    currentDrawingPath.removeAll()
                }) {
                    Image(systemName: "trash")
                }
                Button("保存") {
                    room.layoutPathsCGPoints = paths
                    storageManager.updateRoomLayout(for: room.id, layout: paths, positions: room.cabinetPositions ?? [:])
                    presentationMode.wrappedValue.dismiss()
                }
            }
        }
        .sheet(item: $previewingCabinetNumber) { cabinetNum in
            CabinetPreviewView(storageManager: storageManager, cabinetNumber: cabinetNum)
        }
        .onAppear {
            self.paths = room.layoutPathsCGPoints ?? []
            if room.cabinetPositions == nil {
                room.cabinetPositions = [:]
            }
        }
    }
}

struct CabinetIconView: View {
    let label: String
    let number: String
    
    var body: some View {
        VStack(spacing: 2) {
            Text(label)
                .font(.caption2)
                .lineLimit(1)
                .minimumScaleFactor(0.5)
                .padding(.horizontal, 4)
            Text(number)
                .font(Font.system(.subheadline, design: .monospaced).bold())
        }
        .foregroundColor(.white)
        .frame(width: 60, height: 60)
        .background(Color.brown)
        .clipShape(Circle())
        .overlay(Circle().stroke(Color.white, lineWidth: 2))
        .shadow(color: .black.opacity(0.5), radius: 3, x: 2, y: 2)
    }
}

struct CabinetPreviewView: View {
    @ObservedObject var storageManager: StorageManager
    let cabinetNumber: String
    @Environment(\.presentationMode) var presentationMode
    private let columns: [GridItem] = Array(repeating: .init(.flexible()), count: 3)
    
    var body: some View {
        NavigationView {
            ScrollView {
                if let items = storageManager.itemsByCabinet[cabinetNumber], !items.isEmpty {
                    LazyVGrid(columns: columns, spacing: 15) {
                        ForEach(items) { item in
                            if let uiImage = storageManager.loadImage(fileName: item.imageFileName) {
                                Image(uiImage: uiImage).resizable().aspectRatio(contentMode: .fit).cornerRadius(8)
                            } else {
                                Rectangle().fill(Color.gray.opacity(0.3)).aspectRatio(1, contentMode: .fit).cornerRadius(8).overlay(Image(systemName: "photo.fill").foregroundColor(.white))
                            }
                        }
                    }.padding()
                } else {
                    Text("这个柜子是空的").foregroundColor(.gray).padding(.top, 50)
                }
            }
            .navigationTitle("柜子 \(cabinetNumber) 内物品")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("完成") {
                        presentationMode.wrappedValue.dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - 7. 辅助扩展和UIKit封装 (无变动)
struct ShareSheet: UIViewControllerRepresentable {
    var activityItems: [Any]
    
    func makeUIViewController(context: Context) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
        return controller
    }
    
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}

extension String: @retroactive Identifiable {
    public var id: String { self }
}

extension View {
    func cornerRadius(_ r: CGFloat, c: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: r, corners: c))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(roundedRect: rect, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        return Path(path.cgPath)
    }
}
